// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#ifndef PROTOBUF_data_2eproto__INCLUDED
#define PROTOBUF_data_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace sfm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_data_2eproto();
void protobuf_AssignDesc_data_2eproto();
void protobuf_ShutdownFile_data_2eproto();

class CvMatDimProto;
class cvMatProto;
class Keypoints;
class Keypoints_cvKeypoint;
class CameraMatrixProto;
class CameraBodyTransProto;
class MetadataProto;
class CvRectProto;
class FrameProto;

enum cvMatProto_ImageType {
  cvMatProto_ImageType_cvMat = 0,
  cvMatProto_ImageType_JPEG = 1,
  cvMatProto_ImageType_RAW = 2
};
bool cvMatProto_ImageType_IsValid(int value);
const cvMatProto_ImageType cvMatProto_ImageType_ImageType_MIN = cvMatProto_ImageType_cvMat;
const cvMatProto_ImageType cvMatProto_ImageType_ImageType_MAX = cvMatProto_ImageType_RAW;
const int cvMatProto_ImageType_ImageType_ARRAYSIZE = cvMatProto_ImageType_ImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* cvMatProto_ImageType_descriptor();
inline const ::std::string& cvMatProto_ImageType_Name(cvMatProto_ImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    cvMatProto_ImageType_descriptor(), value);
}
inline bool cvMatProto_ImageType_Parse(
    const ::std::string& name, cvMatProto_ImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cvMatProto_ImageType>(
    cvMatProto_ImageType_descriptor(), name, value);
}
enum MetadataProto_SensorType {
  MetadataProto_SensorType_ACCEL = 0,
  MetadataProto_SensorType_GYRO = 1,
  MetadataProto_SensorType_MAGNETO = 2,
  MetadataProto_SensorType_LINACCEL = 3,
  MetadataProto_SensorType_ORIENTATION = 4,
  MetadataProto_SensorType_GRAVITY = 5,
  MetadataProto_SensorType_ROTVECT = 6
};
bool MetadataProto_SensorType_IsValid(int value);
const MetadataProto_SensorType MetadataProto_SensorType_SensorType_MIN = MetadataProto_SensorType_ACCEL;
const MetadataProto_SensorType MetadataProto_SensorType_SensorType_MAX = MetadataProto_SensorType_ROTVECT;
const int MetadataProto_SensorType_SensorType_ARRAYSIZE = MetadataProto_SensorType_SensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MetadataProto_SensorType_descriptor();
inline const ::std::string& MetadataProto_SensorType_Name(MetadataProto_SensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MetadataProto_SensorType_descriptor(), value);
}
inline bool MetadataProto_SensorType_Parse(
    const ::std::string& name, MetadataProto_SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MetadataProto_SensorType>(
    MetadataProto_SensorType_descriptor(), name, value);
}
// ===================================================================

class CvMatDimProto : public ::google::protobuf::Message {
 public:
  CvMatDimProto();
  virtual ~CvMatDimProto();
  
  CvMatDimProto(const CvMatDimProto& from);
  
  inline CvMatDimProto& operator=(const CvMatDimProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CvMatDimProto& default_instance();
  
  void Swap(CvMatDimProto* other);
  
  // implements Message ----------------------------------------------
  
  CvMatDimProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CvMatDimProto& from);
  void MergeFrom(const CvMatDimProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // optional int32 step = 2;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 2;
  inline ::google::protobuf::int32 step() const;
  inline void set_step(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:sfm.CvMatDimProto)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_step();
  inline void clear_has_step();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 step_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static CvMatDimProto* default_instance_;
};
// -------------------------------------------------------------------

class cvMatProto : public ::google::protobuf::Message {
 public:
  cvMatProto();
  virtual ~cvMatProto();
  
  cvMatProto(const cvMatProto& from);
  
  inline cvMatProto& operator=(const cvMatProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const cvMatProto& default_instance();
  
  void Swap(cvMatProto* other);
  
  // implements Message ----------------------------------------------
  
  cvMatProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cvMatProto& from);
  void MergeFrom(const cvMatProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef cvMatProto_ImageType ImageType;
  static const ImageType cvMat = cvMatProto_ImageType_cvMat;
  static const ImageType JPEG = cvMatProto_ImageType_JPEG;
  static const ImageType RAW = cvMatProto_ImageType_RAW;
  static inline bool ImageType_IsValid(int value) {
    return cvMatProto_ImageType_IsValid(value);
  }
  static const ImageType ImageType_MIN =
    cvMatProto_ImageType_ImageType_MIN;
  static const ImageType ImageType_MAX =
    cvMatProto_ImageType_ImageType_MAX;
  static const int ImageType_ARRAYSIZE =
    cvMatProto_ImageType_ImageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImageType_descriptor() {
    return cvMatProto_ImageType_descriptor();
  }
  static inline const ::std::string& ImageType_Name(ImageType value) {
    return cvMatProto_ImageType_Name(value);
  }
  static inline bool ImageType_Parse(const ::std::string& name,
      ImageType* value) {
    return cvMatProto_ImageType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 n_dims = 1;
  inline bool has_n_dims() const;
  inline void clear_n_dims();
  static const int kNDimsFieldNumber = 1;
  inline ::google::protobuf::int32 n_dims() const;
  inline void set_n_dims(::google::protobuf::int32 value);
  
  // repeated .sfm.CvMatDimProto dims = 2;
  inline int dims_size() const;
  inline void clear_dims();
  static const int kDimsFieldNumber = 2;
  inline const ::sfm::CvMatDimProto& dims(int index) const;
  inline ::sfm::CvMatDimProto* mutable_dims(int index);
  inline ::sfm::CvMatDimProto* add_dims();
  inline const ::google::protobuf::RepeatedPtrField< ::sfm::CvMatDimProto >&
      dims() const;
  inline ::google::protobuf::RepeatedPtrField< ::sfm::CvMatDimProto >*
      mutable_dims();
  
  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional bytes bytedata = 4;
  inline bool has_bytedata() const;
  inline void clear_bytedata();
  static const int kBytedataFieldNumber = 4;
  inline const ::std::string& bytedata() const;
  inline void set_bytedata(const ::std::string& value);
  inline void set_bytedata(const char* value);
  inline void set_bytedata(const void* value, size_t size);
  inline ::std::string* mutable_bytedata();
  inline ::std::string* release_bytedata();
  
  // optional .sfm.cvMatProto.ImageType format = 5 [default = cvMat];
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 5;
  inline ::sfm::cvMatProto_ImageType format() const;
  inline void set_format(::sfm::cvMatProto_ImageType value);
  
  // @@protoc_insertion_point(class_scope:sfm.cvMatProto)
 private:
  inline void set_has_n_dims();
  inline void clear_has_n_dims();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_bytedata();
  inline void clear_has_bytedata();
  inline void set_has_format();
  inline void clear_has_format();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::sfm::CvMatDimProto > dims_;
  ::google::protobuf::int32 n_dims_;
  ::google::protobuf::int32 type_;
  ::std::string* bytedata_;
  int format_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static cvMatProto* default_instance_;
};
// -------------------------------------------------------------------

class Keypoints_cvKeypoint : public ::google::protobuf::Message {
 public:
  Keypoints_cvKeypoint();
  virtual ~Keypoints_cvKeypoint();
  
  Keypoints_cvKeypoint(const Keypoints_cvKeypoint& from);
  
  inline Keypoints_cvKeypoint& operator=(const Keypoints_cvKeypoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Keypoints_cvKeypoint& default_instance();
  
  void Swap(Keypoints_cvKeypoint* other);
  
  // implements Message ----------------------------------------------
  
  Keypoints_cvKeypoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Keypoints_cvKeypoint& from);
  void MergeFrom(const Keypoints_cvKeypoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float ptX = 1;
  inline bool has_ptx() const;
  inline void clear_ptx();
  static const int kPtXFieldNumber = 1;
  inline float ptx() const;
  inline void set_ptx(float value);
  
  // optional float ptY = 2;
  inline bool has_pty() const;
  inline void clear_pty();
  static const int kPtYFieldNumber = 2;
  inline float pty() const;
  inline void set_pty(float value);
  
  // optional float size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline float size() const;
  inline void set_size(float value);
  
  // optional float angle = 4 [default = -1];
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 4;
  inline float angle() const;
  inline void set_angle(float value);
  
  // optional float response = 5;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 5;
  inline float response() const;
  inline void set_response(float value);
  
  // optional int32 octave = 6;
  inline bool has_octave() const;
  inline void clear_octave();
  static const int kOctaveFieldNumber = 6;
  inline ::google::protobuf::int32 octave() const;
  inline void set_octave(::google::protobuf::int32 value);
  
  // optional int32 class_id = 7;
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 7;
  inline ::google::protobuf::int32 class_id() const;
  inline void set_class_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:sfm.Keypoints.cvKeypoint)
 private:
  inline void set_has_ptx();
  inline void clear_has_ptx();
  inline void set_has_pty();
  inline void clear_has_pty();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_octave();
  inline void clear_has_octave();
  inline void set_has_class_id();
  inline void clear_has_class_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float ptx_;
  float pty_;
  float size_;
  float angle_;
  float response_;
  ::google::protobuf::int32 octave_;
  ::google::protobuf::int32 class_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static Keypoints_cvKeypoint* default_instance_;
};
// -------------------------------------------------------------------

class Keypoints : public ::google::protobuf::Message {
 public:
  Keypoints();
  virtual ~Keypoints();
  
  Keypoints(const Keypoints& from);
  
  inline Keypoints& operator=(const Keypoints& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Keypoints& default_instance();
  
  void Swap(Keypoints* other);
  
  // implements Message ----------------------------------------------
  
  Keypoints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Keypoints& from);
  void MergeFrom(const Keypoints& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Keypoints_cvKeypoint cvKeypoint;
  
  // accessors -------------------------------------------------------
  
  // repeated .sfm.Keypoints.cvKeypoint keypoints = 1;
  inline int keypoints_size() const;
  inline void clear_keypoints();
  static const int kKeypointsFieldNumber = 1;
  inline const ::sfm::Keypoints_cvKeypoint& keypoints(int index) const;
  inline ::sfm::Keypoints_cvKeypoint* mutable_keypoints(int index);
  inline ::sfm::Keypoints_cvKeypoint* add_keypoints();
  inline const ::google::protobuf::RepeatedPtrField< ::sfm::Keypoints_cvKeypoint >&
      keypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::sfm::Keypoints_cvKeypoint >*
      mutable_keypoints();
  
  // @@protoc_insertion_point(class_scope:sfm.Keypoints)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::sfm::Keypoints_cvKeypoint > keypoints_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static Keypoints* default_instance_;
};
// -------------------------------------------------------------------

class CameraMatrixProto : public ::google::protobuf::Message {
 public:
  CameraMatrixProto();
  virtual ~CameraMatrixProto();
  
  CameraMatrixProto(const CameraMatrixProto& from);
  
  inline CameraMatrixProto& operator=(const CameraMatrixProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraMatrixProto& default_instance();
  
  void Swap(CameraMatrixProto* other);
  
  // implements Message ----------------------------------------------
  
  CameraMatrixProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraMatrixProto& from);
  void MergeFrom(const CameraMatrixProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:sfm.CameraMatrixProto)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< float > data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static CameraMatrixProto* default_instance_;
};
// -------------------------------------------------------------------

class CameraBodyTransProto : public ::google::protobuf::Message {
 public:
  CameraBodyTransProto();
  virtual ~CameraBodyTransProto();
  
  CameraBodyTransProto(const CameraBodyTransProto& from);
  
  inline CameraBodyTransProto& operator=(const CameraBodyTransProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraBodyTransProto& default_instance();
  
  void Swap(CameraBodyTransProto* other);
  
  // implements Message ----------------------------------------------
  
  CameraBodyTransProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraBodyTransProto& from);
  void MergeFrom(const CameraBodyTransProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:sfm.CameraBodyTransProto)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< float > data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static CameraBodyTransProto* default_instance_;
};
// -------------------------------------------------------------------

class MetadataProto : public ::google::protobuf::Message {
 public:
  MetadataProto();
  virtual ~MetadataProto();
  
  MetadataProto(const MetadataProto& from);
  
  inline MetadataProto& operator=(const MetadataProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetadataProto& default_instance();
  
  void Swap(MetadataProto* other);
  
  // implements Message ----------------------------------------------
  
  MetadataProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetadataProto& from);
  void MergeFrom(const MetadataProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MetadataProto_SensorType SensorType;
  static const SensorType ACCEL = MetadataProto_SensorType_ACCEL;
  static const SensorType GYRO = MetadataProto_SensorType_GYRO;
  static const SensorType MAGNETO = MetadataProto_SensorType_MAGNETO;
  static const SensorType LINACCEL = MetadataProto_SensorType_LINACCEL;
  static const SensorType ORIENTATION = MetadataProto_SensorType_ORIENTATION;
  static const SensorType GRAVITY = MetadataProto_SensorType_GRAVITY;
  static const SensorType ROTVECT = MetadataProto_SensorType_ROTVECT;
  static inline bool SensorType_IsValid(int value) {
    return MetadataProto_SensorType_IsValid(value);
  }
  static const SensorType SensorType_MIN =
    MetadataProto_SensorType_SensorType_MIN;
  static const SensorType SensorType_MAX =
    MetadataProto_SensorType_SensorType_MAX;
  static const int SensorType_ARRAYSIZE =
    MetadataProto_SensorType_SensorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SensorType_descriptor() {
    return MetadataProto_SensorType_descriptor();
  }
  static inline const ::std::string& SensorType_Name(SensorType value) {
    return MetadataProto_SensorType_Name(value);
  }
  static inline bool SensorType_Parse(const ::std::string& name,
      SensorType* value) {
    return MetadataProto_SensorType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional float ang_x = 1;
  inline bool has_ang_x() const;
  inline void clear_ang_x();
  static const int kAngXFieldNumber = 1;
  inline float ang_x() const;
  inline void set_ang_x(float value);
  
  // optional float ang_y = 2;
  inline bool has_ang_y() const;
  inline void clear_ang_y();
  static const int kAngYFieldNumber = 2;
  inline float ang_y() const;
  inline void set_ang_y(float value);
  
  // optional float ang_z = 3;
  inline bool has_ang_z() const;
  inline void clear_ang_z();
  static const int kAngZFieldNumber = 3;
  inline float ang_z() const;
  inline void set_ang_z(float value);
  
  // optional float pos_x = 4;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 4;
  inline float pos_x() const;
  inline void set_pos_x(float value);
  
  // optional float pos_y = 5;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 5;
  inline float pos_y() const;
  inline void set_pos_y(float value);
  
  // optional float pos_z = 6;
  inline bool has_pos_z() const;
  inline void clear_pos_z();
  static const int kPosZFieldNumber = 6;
  inline float pos_z() const;
  inline void set_pos_z(float value);
  
  // optional fixed64 timestamp = 7;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // optional float val_0 = 8;
  inline bool has_val_0() const;
  inline void clear_val_0();
  static const int kVal0FieldNumber = 8;
  inline float val_0() const;
  inline void set_val_0(float value);
  
  // optional float val_1 = 9;
  inline bool has_val_1() const;
  inline void clear_val_1();
  static const int kVal1FieldNumber = 9;
  inline float val_1() const;
  inline void set_val_1(float value);
  
  // optional float val_2 = 10;
  inline bool has_val_2() const;
  inline void clear_val_2();
  static const int kVal2FieldNumber = 10;
  inline float val_2() const;
  inline void set_val_2(float value);
  
  // optional .sfm.MetadataProto.SensorType type = 11 [default = GRAVITY];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 11;
  inline ::sfm::MetadataProto_SensorType type() const;
  inline void set_type(::sfm::MetadataProto_SensorType value);
  
  // @@protoc_insertion_point(class_scope:sfm.MetadataProto)
 private:
  inline void set_has_ang_x();
  inline void clear_has_ang_x();
  inline void set_has_ang_y();
  inline void clear_has_ang_y();
  inline void set_has_ang_z();
  inline void clear_has_ang_z();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();
  inline void set_has_pos_z();
  inline void clear_has_pos_z();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_val_0();
  inline void clear_has_val_0();
  inline void set_has_val_1();
  inline void clear_has_val_1();
  inline void set_has_val_2();
  inline void clear_has_val_2();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float ang_x_;
  float ang_y_;
  float ang_z_;
  float pos_x_;
  float pos_y_;
  float pos_z_;
  ::google::protobuf::uint64 timestamp_;
  float val_0_;
  float val_1_;
  float val_2_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static MetadataProto* default_instance_;
};
// -------------------------------------------------------------------

class CvRectProto : public ::google::protobuf::Message {
 public:
  CvRectProto();
  virtual ~CvRectProto();
  
  CvRectProto(const CvRectProto& from);
  
  inline CvRectProto& operator=(const CvRectProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CvRectProto& default_instance();
  
  void Swap(CvRectProto* other);
  
  // implements Message ----------------------------------------------
  
  CvRectProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CvRectProto& from);
  void MergeFrom(const CvRectProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:sfm.CvRectProto)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static CvRectProto* default_instance_;
};
// -------------------------------------------------------------------

class FrameProto : public ::google::protobuf::Message {
 public:
  FrameProto();
  virtual ~FrameProto();
  
  FrameProto(const FrameProto& from);
  
  inline FrameProto& operator=(const FrameProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameProto& default_instance();
  
  void Swap(FrameProto* other);
  
  // implements Message ----------------------------------------------
  
  FrameProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameProto& from);
  void MergeFrom(const FrameProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .sfm.cvMatProto images = 1;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 1;
  inline const ::sfm::cvMatProto& images(int index) const;
  inline ::sfm::cvMatProto* mutable_images(int index);
  inline ::sfm::cvMatProto* add_images();
  inline const ::google::protobuf::RepeatedPtrField< ::sfm::cvMatProto >&
      images() const;
  inline ::google::protobuf::RepeatedPtrField< ::sfm::cvMatProto >*
      mutable_images();
  
  // optional .sfm.CameraMatrixProto cameraMatrix = 2;
  inline bool has_cameramatrix() const;
  inline void clear_cameramatrix();
  static const int kCameraMatrixFieldNumber = 2;
  inline const ::sfm::CameraMatrixProto& cameramatrix() const;
  inline ::sfm::CameraMatrixProto* mutable_cameramatrix();
  inline ::sfm::CameraMatrixProto* release_cameramatrix();
  
  // optional .sfm.CameraBodyTransProto cameraBodyTrans = 3;
  inline bool has_camerabodytrans() const;
  inline void clear_camerabodytrans();
  static const int kCameraBodyTransFieldNumber = 3;
  inline const ::sfm::CameraBodyTransProto& camerabodytrans() const;
  inline ::sfm::CameraBodyTransProto* mutable_camerabodytrans();
  inline ::sfm::CameraBodyTransProto* release_camerabodytrans();
  
  // optional .sfm.MetadataProto metadata = 4;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 4;
  inline const ::sfm::MetadataProto& metadata() const;
  inline ::sfm::MetadataProto* mutable_metadata();
  inline ::sfm::MetadataProto* release_metadata();
  
  // optional fixed64 id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional fixed64 seq = 6;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 6;
  inline ::google::protobuf::uint64 seq() const;
  inline void set_seq(::google::protobuf::uint64 value);
  
  // optional float baseline = 8;
  inline bool has_baseline() const;
  inline void clear_baseline();
  static const int kBaselineFieldNumber = 8;
  inline float baseline() const;
  inline void set_baseline(float value);
  
  // optional .sfm.CvRectProto roi = 9;
  inline bool has_roi() const;
  inline void clear_roi();
  static const int kRoiFieldNumber = 9;
  inline const ::sfm::CvRectProto& roi() const;
  inline ::sfm::CvRectProto* mutable_roi();
  inline ::sfm::CvRectProto* release_roi();
  
  // optional .sfm.Keypoints keypoints = 10;
  inline bool has_keypoints() const;
  inline void clear_keypoints();
  static const int kKeypointsFieldNumber = 10;
  inline const ::sfm::Keypoints& keypoints() const;
  inline ::sfm::Keypoints* mutable_keypoints();
  inline ::sfm::Keypoints* release_keypoints();
  
  // optional .sfm.cvMatProto descriptors = 11;
  inline bool has_descriptors() const;
  inline void clear_descriptors();
  static const int kDescriptorsFieldNumber = 11;
  inline const ::sfm::cvMatProto& descriptors() const;
  inline ::sfm::cvMatProto* mutable_descriptors();
  inline ::sfm::cvMatProto* release_descriptors();
  
  // @@protoc_insertion_point(class_scope:sfm.FrameProto)
 private:
  inline void set_has_cameramatrix();
  inline void clear_has_cameramatrix();
  inline void set_has_camerabodytrans();
  inline void clear_has_camerabodytrans();
  inline void set_has_metadata();
  inline void clear_has_metadata();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_baseline();
  inline void clear_has_baseline();
  inline void set_has_roi();
  inline void clear_has_roi();
  inline void set_has_keypoints();
  inline void clear_has_keypoints();
  inline void set_has_descriptors();
  inline void clear_has_descriptors();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::sfm::cvMatProto > images_;
  ::sfm::CameraMatrixProto* cameramatrix_;
  ::sfm::CameraBodyTransProto* camerabodytrans_;
  ::sfm::MetadataProto* metadata_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 seq_;
  ::sfm::CvRectProto* roi_;
  ::sfm::Keypoints* keypoints_;
  ::sfm::cvMatProto* descriptors_;
  float baseline_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();
  
  void InitAsDefaultInstance();
  static FrameProto* default_instance_;
};
// ===================================================================


// ===================================================================

// CvMatDimProto

// optional int32 size = 1;
inline bool CvMatDimProto::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CvMatDimProto::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CvMatDimProto::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CvMatDimProto::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 CvMatDimProto::size() const {
  return size_;
}
inline void CvMatDimProto::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional int32 step = 2;
inline bool CvMatDimProto::has_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CvMatDimProto::set_has_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CvMatDimProto::clear_has_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CvMatDimProto::clear_step() {
  step_ = 0;
  clear_has_step();
}
inline ::google::protobuf::int32 CvMatDimProto::step() const {
  return step_;
}
inline void CvMatDimProto::set_step(::google::protobuf::int32 value) {
  set_has_step();
  step_ = value;
}

// -------------------------------------------------------------------

// cvMatProto

// optional int32 n_dims = 1;
inline bool cvMatProto::has_n_dims() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cvMatProto::set_has_n_dims() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cvMatProto::clear_has_n_dims() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cvMatProto::clear_n_dims() {
  n_dims_ = 0;
  clear_has_n_dims();
}
inline ::google::protobuf::int32 cvMatProto::n_dims() const {
  return n_dims_;
}
inline void cvMatProto::set_n_dims(::google::protobuf::int32 value) {
  set_has_n_dims();
  n_dims_ = value;
}

// repeated .sfm.CvMatDimProto dims = 2;
inline int cvMatProto::dims_size() const {
  return dims_.size();
}
inline void cvMatProto::clear_dims() {
  dims_.Clear();
}
inline const ::sfm::CvMatDimProto& cvMatProto::dims(int index) const {
  return dims_.Get(index);
}
inline ::sfm::CvMatDimProto* cvMatProto::mutable_dims(int index) {
  return dims_.Mutable(index);
}
inline ::sfm::CvMatDimProto* cvMatProto::add_dims() {
  return dims_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sfm::CvMatDimProto >&
cvMatProto::dims() const {
  return dims_;
}
inline ::google::protobuf::RepeatedPtrField< ::sfm::CvMatDimProto >*
cvMatProto::mutable_dims() {
  return &dims_;
}

// optional int32 type = 3;
inline bool cvMatProto::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cvMatProto::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cvMatProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cvMatProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 cvMatProto::type() const {
  return type_;
}
inline void cvMatProto::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes bytedata = 4;
inline bool cvMatProto::has_bytedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cvMatProto::set_has_bytedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cvMatProto::clear_has_bytedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cvMatProto::clear_bytedata() {
  if (bytedata_ != &::google::protobuf::internal::kEmptyString) {
    bytedata_->clear();
  }
  clear_has_bytedata();
}
inline const ::std::string& cvMatProto::bytedata() const {
  return *bytedata_;
}
inline void cvMatProto::set_bytedata(const ::std::string& value) {
  set_has_bytedata();
  if (bytedata_ == &::google::protobuf::internal::kEmptyString) {
    bytedata_ = new ::std::string;
  }
  bytedata_->assign(value);
}
inline void cvMatProto::set_bytedata(const char* value) {
  set_has_bytedata();
  if (bytedata_ == &::google::protobuf::internal::kEmptyString) {
    bytedata_ = new ::std::string;
  }
  bytedata_->assign(value);
}
inline void cvMatProto::set_bytedata(const void* value, size_t size) {
  set_has_bytedata();
  if (bytedata_ == &::google::protobuf::internal::kEmptyString) {
    bytedata_ = new ::std::string;
  }
  bytedata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cvMatProto::mutable_bytedata() {
  set_has_bytedata();
  if (bytedata_ == &::google::protobuf::internal::kEmptyString) {
    bytedata_ = new ::std::string;
  }
  return bytedata_;
}
inline ::std::string* cvMatProto::release_bytedata() {
  clear_has_bytedata();
  if (bytedata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bytedata_;
    bytedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .sfm.cvMatProto.ImageType format = 5 [default = cvMat];
inline bool cvMatProto::has_format() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cvMatProto::set_has_format() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cvMatProto::clear_has_format() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cvMatProto::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::sfm::cvMatProto_ImageType cvMatProto::format() const {
  return static_cast< ::sfm::cvMatProto_ImageType >(format_);
}
inline void cvMatProto::set_format(::sfm::cvMatProto_ImageType value) {
  GOOGLE_DCHECK(::sfm::cvMatProto_ImageType_IsValid(value));
  set_has_format();
  format_ = value;
}

// -------------------------------------------------------------------

// Keypoints_cvKeypoint

// optional float ptX = 1;
inline bool Keypoints_cvKeypoint::has_ptx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Keypoints_cvKeypoint::set_has_ptx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Keypoints_cvKeypoint::clear_has_ptx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Keypoints_cvKeypoint::clear_ptx() {
  ptx_ = 0;
  clear_has_ptx();
}
inline float Keypoints_cvKeypoint::ptx() const {
  return ptx_;
}
inline void Keypoints_cvKeypoint::set_ptx(float value) {
  set_has_ptx();
  ptx_ = value;
}

// optional float ptY = 2;
inline bool Keypoints_cvKeypoint::has_pty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Keypoints_cvKeypoint::set_has_pty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Keypoints_cvKeypoint::clear_has_pty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Keypoints_cvKeypoint::clear_pty() {
  pty_ = 0;
  clear_has_pty();
}
inline float Keypoints_cvKeypoint::pty() const {
  return pty_;
}
inline void Keypoints_cvKeypoint::set_pty(float value) {
  set_has_pty();
  pty_ = value;
}

// optional float size = 3;
inline bool Keypoints_cvKeypoint::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Keypoints_cvKeypoint::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Keypoints_cvKeypoint::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Keypoints_cvKeypoint::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline float Keypoints_cvKeypoint::size() const {
  return size_;
}
inline void Keypoints_cvKeypoint::set_size(float value) {
  set_has_size();
  size_ = value;
}

// optional float angle = 4 [default = -1];
inline bool Keypoints_cvKeypoint::has_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Keypoints_cvKeypoint::set_has_angle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Keypoints_cvKeypoint::clear_has_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Keypoints_cvKeypoint::clear_angle() {
  angle_ = -1;
  clear_has_angle();
}
inline float Keypoints_cvKeypoint::angle() const {
  return angle_;
}
inline void Keypoints_cvKeypoint::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional float response = 5;
inline bool Keypoints_cvKeypoint::has_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Keypoints_cvKeypoint::set_has_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Keypoints_cvKeypoint::clear_has_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Keypoints_cvKeypoint::clear_response() {
  response_ = 0;
  clear_has_response();
}
inline float Keypoints_cvKeypoint::response() const {
  return response_;
}
inline void Keypoints_cvKeypoint::set_response(float value) {
  set_has_response();
  response_ = value;
}

// optional int32 octave = 6;
inline bool Keypoints_cvKeypoint::has_octave() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Keypoints_cvKeypoint::set_has_octave() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Keypoints_cvKeypoint::clear_has_octave() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Keypoints_cvKeypoint::clear_octave() {
  octave_ = 0;
  clear_has_octave();
}
inline ::google::protobuf::int32 Keypoints_cvKeypoint::octave() const {
  return octave_;
}
inline void Keypoints_cvKeypoint::set_octave(::google::protobuf::int32 value) {
  set_has_octave();
  octave_ = value;
}

// optional int32 class_id = 7;
inline bool Keypoints_cvKeypoint::has_class_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Keypoints_cvKeypoint::set_has_class_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Keypoints_cvKeypoint::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Keypoints_cvKeypoint::clear_class_id() {
  class_id_ = 0;
  clear_has_class_id();
}
inline ::google::protobuf::int32 Keypoints_cvKeypoint::class_id() const {
  return class_id_;
}
inline void Keypoints_cvKeypoint::set_class_id(::google::protobuf::int32 value) {
  set_has_class_id();
  class_id_ = value;
}

// -------------------------------------------------------------------

// Keypoints

// repeated .sfm.Keypoints.cvKeypoint keypoints = 1;
inline int Keypoints::keypoints_size() const {
  return keypoints_.size();
}
inline void Keypoints::clear_keypoints() {
  keypoints_.Clear();
}
inline const ::sfm::Keypoints_cvKeypoint& Keypoints::keypoints(int index) const {
  return keypoints_.Get(index);
}
inline ::sfm::Keypoints_cvKeypoint* Keypoints::mutable_keypoints(int index) {
  return keypoints_.Mutable(index);
}
inline ::sfm::Keypoints_cvKeypoint* Keypoints::add_keypoints() {
  return keypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sfm::Keypoints_cvKeypoint >&
Keypoints::keypoints() const {
  return keypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::sfm::Keypoints_cvKeypoint >*
Keypoints::mutable_keypoints() {
  return &keypoints_;
}

// -------------------------------------------------------------------

// CameraMatrixProto

// repeated float data = 1;
inline int CameraMatrixProto::data_size() const {
  return data_.size();
}
inline void CameraMatrixProto::clear_data() {
  data_.Clear();
}
inline float CameraMatrixProto::data(int index) const {
  return data_.Get(index);
}
inline void CameraMatrixProto::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void CameraMatrixProto::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
CameraMatrixProto::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraMatrixProto::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// CameraBodyTransProto

// repeated float data = 1;
inline int CameraBodyTransProto::data_size() const {
  return data_.size();
}
inline void CameraBodyTransProto::clear_data() {
  data_.Clear();
}
inline float CameraBodyTransProto::data(int index) const {
  return data_.Get(index);
}
inline void CameraBodyTransProto::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void CameraBodyTransProto::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
CameraBodyTransProto::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraBodyTransProto::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// MetadataProto

// optional float ang_x = 1;
inline bool MetadataProto::has_ang_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetadataProto::set_has_ang_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetadataProto::clear_has_ang_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetadataProto::clear_ang_x() {
  ang_x_ = 0;
  clear_has_ang_x();
}
inline float MetadataProto::ang_x() const {
  return ang_x_;
}
inline void MetadataProto::set_ang_x(float value) {
  set_has_ang_x();
  ang_x_ = value;
}

// optional float ang_y = 2;
inline bool MetadataProto::has_ang_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetadataProto::set_has_ang_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetadataProto::clear_has_ang_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetadataProto::clear_ang_y() {
  ang_y_ = 0;
  clear_has_ang_y();
}
inline float MetadataProto::ang_y() const {
  return ang_y_;
}
inline void MetadataProto::set_ang_y(float value) {
  set_has_ang_y();
  ang_y_ = value;
}

// optional float ang_z = 3;
inline bool MetadataProto::has_ang_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetadataProto::set_has_ang_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetadataProto::clear_has_ang_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetadataProto::clear_ang_z() {
  ang_z_ = 0;
  clear_has_ang_z();
}
inline float MetadataProto::ang_z() const {
  return ang_z_;
}
inline void MetadataProto::set_ang_z(float value) {
  set_has_ang_z();
  ang_z_ = value;
}

// optional float pos_x = 4;
inline bool MetadataProto::has_pos_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetadataProto::set_has_pos_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetadataProto::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetadataProto::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline float MetadataProto::pos_x() const {
  return pos_x_;
}
inline void MetadataProto::set_pos_x(float value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional float pos_y = 5;
inline bool MetadataProto::has_pos_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetadataProto::set_has_pos_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetadataProto::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetadataProto::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline float MetadataProto::pos_y() const {
  return pos_y_;
}
inline void MetadataProto::set_pos_y(float value) {
  set_has_pos_y();
  pos_y_ = value;
}

// optional float pos_z = 6;
inline bool MetadataProto::has_pos_z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MetadataProto::set_has_pos_z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MetadataProto::clear_has_pos_z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MetadataProto::clear_pos_z() {
  pos_z_ = 0;
  clear_has_pos_z();
}
inline float MetadataProto::pos_z() const {
  return pos_z_;
}
inline void MetadataProto::set_pos_z(float value) {
  set_has_pos_z();
  pos_z_ = value;
}

// optional fixed64 timestamp = 7;
inline bool MetadataProto::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MetadataProto::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MetadataProto::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MetadataProto::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 MetadataProto::timestamp() const {
  return timestamp_;
}
inline void MetadataProto::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional float val_0 = 8;
inline bool MetadataProto::has_val_0() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MetadataProto::set_has_val_0() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MetadataProto::clear_has_val_0() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MetadataProto::clear_val_0() {
  val_0_ = 0;
  clear_has_val_0();
}
inline float MetadataProto::val_0() const {
  return val_0_;
}
inline void MetadataProto::set_val_0(float value) {
  set_has_val_0();
  val_0_ = value;
}

// optional float val_1 = 9;
inline bool MetadataProto::has_val_1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MetadataProto::set_has_val_1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MetadataProto::clear_has_val_1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MetadataProto::clear_val_1() {
  val_1_ = 0;
  clear_has_val_1();
}
inline float MetadataProto::val_1() const {
  return val_1_;
}
inline void MetadataProto::set_val_1(float value) {
  set_has_val_1();
  val_1_ = value;
}

// optional float val_2 = 10;
inline bool MetadataProto::has_val_2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MetadataProto::set_has_val_2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MetadataProto::clear_has_val_2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MetadataProto::clear_val_2() {
  val_2_ = 0;
  clear_has_val_2();
}
inline float MetadataProto::val_2() const {
  return val_2_;
}
inline void MetadataProto::set_val_2(float value) {
  set_has_val_2();
  val_2_ = value;
}

// optional .sfm.MetadataProto.SensorType type = 11 [default = GRAVITY];
inline bool MetadataProto::has_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MetadataProto::set_has_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MetadataProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MetadataProto::clear_type() {
  type_ = 5;
  clear_has_type();
}
inline ::sfm::MetadataProto_SensorType MetadataProto::type() const {
  return static_cast< ::sfm::MetadataProto_SensorType >(type_);
}
inline void MetadataProto::set_type(::sfm::MetadataProto_SensorType value) {
  GOOGLE_DCHECK(::sfm::MetadataProto_SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CvRectProto

// optional int32 x = 1;
inline bool CvRectProto::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CvRectProto::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CvRectProto::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CvRectProto::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 CvRectProto::x() const {
  return x_;
}
inline void CvRectProto::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 2;
inline bool CvRectProto::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CvRectProto::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CvRectProto::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CvRectProto::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 CvRectProto::y() const {
  return y_;
}
inline void CvRectProto::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 width = 3;
inline bool CvRectProto::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CvRectProto::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CvRectProto::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CvRectProto::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 CvRectProto::width() const {
  return width_;
}
inline void CvRectProto::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 4;
inline bool CvRectProto::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CvRectProto::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CvRectProto::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CvRectProto::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 CvRectProto::height() const {
  return height_;
}
inline void CvRectProto::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// FrameProto

// repeated .sfm.cvMatProto images = 1;
inline int FrameProto::images_size() const {
  return images_.size();
}
inline void FrameProto::clear_images() {
  images_.Clear();
}
inline const ::sfm::cvMatProto& FrameProto::images(int index) const {
  return images_.Get(index);
}
inline ::sfm::cvMatProto* FrameProto::mutable_images(int index) {
  return images_.Mutable(index);
}
inline ::sfm::cvMatProto* FrameProto::add_images() {
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sfm::cvMatProto >&
FrameProto::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::sfm::cvMatProto >*
FrameProto::mutable_images() {
  return &images_;
}

// optional .sfm.CameraMatrixProto cameraMatrix = 2;
inline bool FrameProto::has_cameramatrix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameProto::set_has_cameramatrix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameProto::clear_has_cameramatrix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameProto::clear_cameramatrix() {
  if (cameramatrix_ != NULL) cameramatrix_->::sfm::CameraMatrixProto::Clear();
  clear_has_cameramatrix();
}
inline const ::sfm::CameraMatrixProto& FrameProto::cameramatrix() const {
  return cameramatrix_ != NULL ? *cameramatrix_ : *default_instance_->cameramatrix_;
}
inline ::sfm::CameraMatrixProto* FrameProto::mutable_cameramatrix() {
  set_has_cameramatrix();
  if (cameramatrix_ == NULL) cameramatrix_ = new ::sfm::CameraMatrixProto;
  return cameramatrix_;
}
inline ::sfm::CameraMatrixProto* FrameProto::release_cameramatrix() {
  clear_has_cameramatrix();
  ::sfm::CameraMatrixProto* temp = cameramatrix_;
  cameramatrix_ = NULL;
  return temp;
}

// optional .sfm.CameraBodyTransProto cameraBodyTrans = 3;
inline bool FrameProto::has_camerabodytrans() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameProto::set_has_camerabodytrans() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameProto::clear_has_camerabodytrans() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameProto::clear_camerabodytrans() {
  if (camerabodytrans_ != NULL) camerabodytrans_->::sfm::CameraBodyTransProto::Clear();
  clear_has_camerabodytrans();
}
inline const ::sfm::CameraBodyTransProto& FrameProto::camerabodytrans() const {
  return camerabodytrans_ != NULL ? *camerabodytrans_ : *default_instance_->camerabodytrans_;
}
inline ::sfm::CameraBodyTransProto* FrameProto::mutable_camerabodytrans() {
  set_has_camerabodytrans();
  if (camerabodytrans_ == NULL) camerabodytrans_ = new ::sfm::CameraBodyTransProto;
  return camerabodytrans_;
}
inline ::sfm::CameraBodyTransProto* FrameProto::release_camerabodytrans() {
  clear_has_camerabodytrans();
  ::sfm::CameraBodyTransProto* temp = camerabodytrans_;
  camerabodytrans_ = NULL;
  return temp;
}

// optional .sfm.MetadataProto metadata = 4;
inline bool FrameProto::has_metadata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrameProto::set_has_metadata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrameProto::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrameProto::clear_metadata() {
  if (metadata_ != NULL) metadata_->::sfm::MetadataProto::Clear();
  clear_has_metadata();
}
inline const ::sfm::MetadataProto& FrameProto::metadata() const {
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::sfm::MetadataProto* FrameProto::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) metadata_ = new ::sfm::MetadataProto;
  return metadata_;
}
inline ::sfm::MetadataProto* FrameProto::release_metadata() {
  clear_has_metadata();
  ::sfm::MetadataProto* temp = metadata_;
  metadata_ = NULL;
  return temp;
}

// optional fixed64 id = 5;
inline bool FrameProto::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrameProto::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FrameProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FrameProto::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 FrameProto::id() const {
  return id_;
}
inline void FrameProto::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional fixed64 seq = 6;
inline bool FrameProto::has_seq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FrameProto::set_has_seq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FrameProto::clear_has_seq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FrameProto::clear_seq() {
  seq_ = GOOGLE_ULONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::uint64 FrameProto::seq() const {
  return seq_;
}
inline void FrameProto::set_seq(::google::protobuf::uint64 value) {
  set_has_seq();
  seq_ = value;
}

// optional float baseline = 8;
inline bool FrameProto::has_baseline() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FrameProto::set_has_baseline() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FrameProto::clear_has_baseline() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FrameProto::clear_baseline() {
  baseline_ = 0;
  clear_has_baseline();
}
inline float FrameProto::baseline() const {
  return baseline_;
}
inline void FrameProto::set_baseline(float value) {
  set_has_baseline();
  baseline_ = value;
}

// optional .sfm.CvRectProto roi = 9;
inline bool FrameProto::has_roi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FrameProto::set_has_roi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FrameProto::clear_has_roi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FrameProto::clear_roi() {
  if (roi_ != NULL) roi_->::sfm::CvRectProto::Clear();
  clear_has_roi();
}
inline const ::sfm::CvRectProto& FrameProto::roi() const {
  return roi_ != NULL ? *roi_ : *default_instance_->roi_;
}
inline ::sfm::CvRectProto* FrameProto::mutable_roi() {
  set_has_roi();
  if (roi_ == NULL) roi_ = new ::sfm::CvRectProto;
  return roi_;
}
inline ::sfm::CvRectProto* FrameProto::release_roi() {
  clear_has_roi();
  ::sfm::CvRectProto* temp = roi_;
  roi_ = NULL;
  return temp;
}

// optional .sfm.Keypoints keypoints = 10;
inline bool FrameProto::has_keypoints() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FrameProto::set_has_keypoints() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FrameProto::clear_has_keypoints() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FrameProto::clear_keypoints() {
  if (keypoints_ != NULL) keypoints_->::sfm::Keypoints::Clear();
  clear_has_keypoints();
}
inline const ::sfm::Keypoints& FrameProto::keypoints() const {
  return keypoints_ != NULL ? *keypoints_ : *default_instance_->keypoints_;
}
inline ::sfm::Keypoints* FrameProto::mutable_keypoints() {
  set_has_keypoints();
  if (keypoints_ == NULL) keypoints_ = new ::sfm::Keypoints;
  return keypoints_;
}
inline ::sfm::Keypoints* FrameProto::release_keypoints() {
  clear_has_keypoints();
  ::sfm::Keypoints* temp = keypoints_;
  keypoints_ = NULL;
  return temp;
}

// optional .sfm.cvMatProto descriptors = 11;
inline bool FrameProto::has_descriptors() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FrameProto::set_has_descriptors() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FrameProto::clear_has_descriptors() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FrameProto::clear_descriptors() {
  if (descriptors_ != NULL) descriptors_->::sfm::cvMatProto::Clear();
  clear_has_descriptors();
}
inline const ::sfm::cvMatProto& FrameProto::descriptors() const {
  return descriptors_ != NULL ? *descriptors_ : *default_instance_->descriptors_;
}
inline ::sfm::cvMatProto* FrameProto::mutable_descriptors() {
  set_has_descriptors();
  if (descriptors_ == NULL) descriptors_ = new ::sfm::cvMatProto;
  return descriptors_;
}
inline ::sfm::cvMatProto* FrameProto::release_descriptors() {
  clear_has_descriptors();
  ::sfm::cvMatProto* temp = descriptors_;
  descriptors_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sfm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sfm::cvMatProto_ImageType>() {
  return ::sfm::cvMatProto_ImageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sfm::MetadataProto_SensorType>() {
  return ::sfm::MetadataProto_SensorType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_data_2eproto__INCLUDED
